#### 浏览器的渲染原理



#### 渲染过程遇到JS会如何处理？



#### 什么情况会阻塞渲染？



#### CSS 如何阻塞文档解析？

* css加载不会阻塞DOM树解析

* 但css加载会阻塞DOM树渲染,加载css的时候，可能会修改下面DOM节点的样式，如果css加载不阻塞DOM树渲染的话，那么当css加载完之后，DOM树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。所以我干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，在根据最终的样式来渲染DOM树

* css加载会阻塞后面js语句的执行,经过了2497ms

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Document</title>
      <style>
          h1 {
            color: red !important
          }
        </style>
        <script>
          console.log('before css')
          var startDate = new Date()
        </script>
        <link href="https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css" rel="stylesheet">
      </head>
      <body>
        <h1>这是红色的</h1>
      </body>
      <script>
          var endDate = new Date()
          console.log('after css')
          console.log('经过了' + (endDate -startDate) + 'ms') //经过了2497ms
        </script>
  </html>
  ```

  

#### 



#### 如何在浏览器多个标签之间的通信

* localStorage：在一个标签页里面使用`localStorage.setItem(key,value)`添加(修改、删除)内容;在另一个标签页里面监听`storage`事件。即可得到`localstorge`存储的值，实现不同标签页之间的通信。

  ```javascript
  // 添加
  localStorage.setItem(key,value) 
  // 删除
  localStorage.removeItem(key,value) 
  
  // 添加监听 storage 的变化
  window.onload = function () {
      window.addEventListener('storage', function (event) {
        // event 事件对象包含 domain newValue oldValue key
          console.log(event.key + '=' + event.newValue);
      })
  }
  ```

  

* cookie + setInterval：将要传递的信息存储在cookie中，每隔一定时间读取cookie信息， 即可随时获取要传递的信息。

  在A页面将需要传递的消息存储在cookie当中

  在B页面设置`setInterval`,以一定的时间间隔去读取cookie的值。(不停地问cookie)

* 监听服务器事件

  * WebSocket
  * HTML5新特性SharedWorker



