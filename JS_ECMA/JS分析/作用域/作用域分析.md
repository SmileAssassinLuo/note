### **编译原理**

在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。

+ 分词/词法分析（`Tokenizing/Lexing`） 
  词法分析会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，代码块被称为词法单元（`token`）。例如，考虑程序 `var a = 2;` 。这段程序通常会被分解成为下面这些词法单元： `var` 、` a` 、` = `、 `2`、`; `。**空格**是否会被当作词法单元，取决于空格在这门语言中是否具有意义。
  分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过 ``有状态`` 还是 ``无状态`` 的方式进行的。简单来说，如果词法单元生成器在判断 `a` 是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为 `词法分析` 。
+ 解析/语法分析（Parsing） 
  这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（`Abstract Syntax Tree`，AST）。`var a = 2; `的抽象语法树中可能会有一个叫作 `VariableDeclaration` 的顶级节点，接下来是一个叫作 `Identifier` （它的值是` a` ）的子节点，以及一个叫作 `AssignmentExpression`的子节点。 `AssignmentExpression `节点有一个叫作` NumericLiteral `（它的值是` 2 `）的子节点。
+ 代码生成 
  将 `AST` 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。抛开具体细节，简单来说就是有某种方法可以将 `var a = 2;` 的 `AST `转化为一组机器指令，用来创建一个叫作 `a `的变量（包括分配内存等），并将一个值储存在 `a `中。

首先，`JavaScript `引擎不会有大量的（像其他语言编译器那么多的）时间用来进行优化，因为与其他语言不同，`JavaScript `的编译过程不是发生在构建之前的对于 `JavaScript` 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。

在我们所要讨论的作用域背后，`JavaScript` 引擎用尽了各种办法（比如 `JIT`，可以延迟编译甚至实施重编译）来保证性能最佳。简单地说，任何 `JavaScript` 代码片段在执行前都要进行编译（通常就在执行前）。因此，`JavaScript` 编译器首先会对` var a = 2;` 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。

### **理解作用域**

一段js代码的生成执行过程：会有三个角色来实现；

```javascript
var a = 2 ;
```

+ **引擎**   从头到尾负责整个 J`avaScript` 程序的编译及执行过程。
+ **编译器**  引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见编译原理部分）。
+ **作用域**  引擎的另一位好朋友，**负责收集并维护由所有声明的标识符（变量）组成的一系列查
  询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限**。

从**JS**引擎和编译器开始分析，编译器首先会将这段程序分解成**词法单元**，然后将词法单元解析成一个树结构；

编译器会进行如下处理。
1. 遇到 `var a `，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 `a` 。
2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 `a = 2` 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 `a` 的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。

#### 编译器有话说

编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。

​	**`LHS`和`RHS`**

​	.......

作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 `LHS` 查询；如果目的是获取变量的值，就会使用 `RHS` 查询。

赋值操作符会导致 `LHS` 查询。 ＝ 操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

`JavaScript` 引擎首先会在代码执行前对其进行编译，在这个过程中，像 `var a = 2 `这样的声明会被分解成两个独立的步骤：

1. 首先，` var a` 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。
2. 接下来， `a = 2` 会查询（`LHS` 查询）变量 `a` 并对其进行赋值。

`LHS` 和 `RHS` 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。不成功的 `RHS` 引用会导致抛出 `ReferenceError` 异常。不成功的 `LHS` 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 `LHS` 引用的目标作为标识符，或者抛出` ReferenceError` 异常（严格模式下）。

### **词法作用域**

**词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。**编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。

`JavaScript `中有两个机制可以“欺骗”词法作用域： `eval(..) `和` with `。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。

**词法作用域是在定义时确定的，而动态作用域是在运行时确定的.**

```js
//词法作用域，输出2，在定义时的环境去查找a；
//动态作用域，输出3，在执行时的环境去查找a；
var a = 2;
function foo() {
    console.log( a );
}
function bar() {
    var a = 3;
    foo();
}
bar();
```

#### 函数作用域和块作用域

函数作用域的含义是指，**属于这个函数的全部变量都可以在整个函数的范围内使用及复用**（事实上在嵌套的作用域中也可以使用）；

###### 自由变量

在当前作用域中存在，但未在当前作用域中声明的变量。一旦出现这种变量，就会出现作用域链，此种变量会根据作用域链查找机制，沿着作用域链往上层查找。



#### 闭包

无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包；

```javascript
function foo() {
	var a = 2;
	function bar() {
		console.log( a );
	}
	return bar;
}
var baz = foo();
baz(); // 2 —— 这就是闭包的效果
```

浅析：
函数 `bar()` 的词法作用域能够访问` foo()` 的内部作用域。将 `bar()` 函数本身当作一个值类型进行传递.

将 `bar `所引用的函数对象本身当作返回值。在 `foo()` 执行后，其返回值（也就是内部的 `bar()` 函数）赋值给变量 `baz` 并调用`baz()` ，实际上只是通过不同的标识符引用调用了内部的函数 `bar() `.

调用`bar`是在定义的词法作用域外，通常`foo`执行后，会将作用域销毁，但是`bar`还在使用。拜 `bar()` 所声明的位置所赐，它拥有涵盖 `foo()` 内部作用域的闭包.

**bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。**

##### 闭包的应用

**模块**模式需要具备两个必要条件:

* 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。
* 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。

```javascript
   //通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例修改它们的值
var fod = (function Module(){
    var something = "something";
    var another = [1,2,3];
    function doSomething(){
        console.log(something)
    }
    function doAnother(){
        console.log(another.join("_"))
    }
    return {
        doSomething:doSomething,
        doAnother:doAnother
    }
})();
fod.doSomething();
fod.doAnother();
       
//" foo " 和 "bar" 模块都是通过一个返回公共 API 的函数来定义的。 "foo" 甚至接受 "bar" 的示例作为依赖参数，并能相应地使用它。
var MyModules = (function Manager(){
    var  modules = {};
    function define(name,deps,impl){
        for (var i=0; i<deps.length; i++) {
            deps[i] = modules[deps[i]];
        }
        modules[name] = impl.apply( impl, deps );
    }
    function get(name) {
        return modules[name];
    }
    return {
        define: define,
        get: get
    };
})()
MyModules.define( "bar", [], function() {
    function hello(who) {
        return "Let me introduce: " + who;
    }
    return {
        hello: hello
    };
});
MyModules.define( "foo", ["bar"], function(bar) {
    var hungry = "hippo";
    function awesome() {
        console.log( bar.hello( hungry ).toUpperCase() );
    }
    return {
        awesome: awesome
    };
});
var bar = MyModules.get( "bar" );
var foo = MyModules.get( "foo" );
console.log(bar.hello( "hippo" )); // Let me introduce: hippo
foo.awesome(); // LET ME INTRODUCE: HIPPO
```

要理解模块管理器没有任何特殊的“魔力”。它们符合前面列出的模块模式的两个特点：**为函数定义引入包装函数，并保证它的返回值和模块的 API 保持一致。**换句话说，模块就是模块，即使在它们外层加上一个友好的包装工具也不会发生任何变化。

**模块机制在es6中大有改善，通过import和export 引入导出即可使用，底层机理应和闭包实现类似？？？？**

