#### 连等赋值

##### 一，连等赋值示例

以`A = B = C`为例，

```js
var a = {n:1};  
var b = a; // 持有a，以回查  
a.x = a = {n:2};  
console.log(a.x);// --> undefined  
console.log(b.x);// --> {n:2}
```

##### 二,验证实际操作内容

通过 `getter` 证实，在`A=B=C`中，`C`只被读取了一次。

所以，连等赋值真正的运算规则是 **B = C; A = B;** 即连续赋值是**从右至左永远只取等号右边的表达式结果赋值到等号左侧**。

```js
Object.defineProperty(window,"obj",{
  get:function(){
    console.log("getter!!!");
  }
});
a=b=obj;
//VM9590:3 getter!!!
```

##### 三，分析示例

```js
var a = {n:1};
var b = a;
a.x = a = {n:2};
console.log(a===b.x); //true
```

1、在执行前，会先将a和a.x中的a的引用地址都取出来，此值他们都指向{n:1} ; 

```js
a= {n:1}; a.x = {n:1};
```

2、在内存中创建一个新对象{n:2};

3、执行a={n:2}，将a的引用从指向{n:1}**改为**指向新的{n:2} 

```
a= {n:1} ---> a = {n:2}
```

4、执行a.x=a，此时a已经指向了新对象，**而a.x因为在执行前保留了原引用，所以a.x的a依然指向原先的{n:1}对象**，所以给原对象新增一个属性x，内容为{n:2}也就是现在a;

```
a.x = {n:1};
原a = {n:1} ; //保留的引用
//增加x属性
原a = {
	x:{n:2},  // 由 {n:1} --> {n:2}
	n:1
}  //无引用，回收
新a = {n:2}; 
b = 新a;
```

5、语句执行结束，原对象由{n:1}变成{n:1,x:{n:2}}，而原对象因为无人再引用他，所以被GC回收，当前a指向新对象{n:2}

6、所以就有了运行结果，再执行a.x，自然就是undefined了

**尽量不要使用JS的连续赋值操作，除非真的了解它的内部机制及可能会产生的后果**

